**IM系统设计思路**
==================

# 关键点

#### 1. 长连接

##### 技术方案

Tomcat，Spring的WebSocket，MQTT，STOMP，Netty

选用Netty，适合高并发和NIO

##### 心跳确认保活：

* 客户端（Android）：发送PING心跳Socket
* 服务端（Spring）：收到PING之后响应PONG
* 重连机制：
  * 前端每30秒发送一次PING确定在线。如果5秒没有收到PONG就断开连接尝试重联，重连每隔
  * Androi注册ConnectivityManager.NetworkCallback监听网络变化，onLost之后进行重连。

#### 2. 消息传递

##### 应用层

即时通讯消息：Socket（Netty）传递；大量资源获取消息：Http（WebFlux）

##### 传输层

可靠消息：TCP传输；及时通讯消息（p2p视频，直播）：UDP传输。

##### 消息传输类型

及时通讯消息ProtoBuff序列化传递；非及时消息：JSON（文本）、字节流（文件）

##### 消息唯一UUID

数据库使用long timestamp快速索引

业务层UUID为senderAccount_receiverAccount_timestamp（业务层设定userAccount不能包含下划线）

##### 消息确认机制

在客户端channel激活的情况下，将消息发送给客户端，如果收到消息则将消息标记为已发送并持久化。在10秒内没有收到确认收到消息则从新发送消息。超过n此从新发送失败则主动发送PONG等待响应，如果超过30秒未响应则将channel断开。并将未发送的消息持久化。

已读功能：用户端点开页面发送已读响应。

是否已发和是否已读：user_session表中存储最后已发消息的截至时间戳；存储是否已读的截至时间错；并将状态同步到Redis

#### 3. 后端持久化

##### 持久化策略

* 服务将收到的消息存入消息队列，在CPU空闲的时候执行持久化操作：削峰填谷。
* 消息先加入缓存，然后将消息流入ES和MongoDB并MySQL存储索引。
* 定时任务，定时将时间久远的冷数据用MQ在CPU空闲执行异步任务存储到HBase。
* MySQL消息立刻存储或者高优先级存储，因为是属于索引级别。

##### 存储设计

**消息表设计**：设计合理的数据库表结构，包括消息表、用户表、群组表等。

**消息索引**：为消息表添加适当的索引，提高查询性能。

**复合索引**：根据实际查询需求，创建复合索引，提高查询性能。

**分区表**：对大表进行分区，提高查询和写入性能。

**分表分库哈希表索引**：两两用户之间一个会话表存储消息，会话表的哈希索引存储在MySQL中。

**分布式文件系统**：对于大文件（如图片、视频），使用分布式文件系统（如HDFS、Ceph）进行存储，提高存储效率和可靠性。

**对象存储**：使用云对象存储服务（如AWS S3、阿里云OSS）进行文件存储，提供高可用性和高扩展性。

##### 查询设计

- **缓存查询**：Redis存储缓存用于直接查询。
- **分页查询**：实现分页查询功能，支持用户查看历史消息。
- **全文搜索**：集成Elasticsearch，实现消息的全文搜索功能。

##### 未处理消息缓存：RabbitMQ

未处理的消息先缓存在RabbitMQ中，并记录用户为收到消息用户索引以及数量。前端查询到存在未处理消息的时候调用查询消息的Http请求。RabbitMQ将未处理的消息交给前端。

* **离线消息**：当用户不在线时，将消息存储到离线消息，用户上线后进行推送。

##### 最近消息缓存：Redis缓存最近消息

* 缓存结构：
  * key1："chatLast:${senderAccount}:${receiverAccount}:"；用于缓存最近一条的聊天记录和未读消息数（前端聊天列表展示）
  * key2："chatRecent:${senderAccount}:${receiverAccount}"；最近20条聊天记录（前端打开聊天页面初始化，并且不往上滑动拉取历史消息的情况）
  * key的有效时长7day
  * 结构：基本消息类型（用于展示在前端消息列表） + 未读数量（用于前端Http请求数量）
* 首次启动服务从数据库拉取数据存储到Redis数据防止大量的缓存击穿

##### 核心业务信息：MySQL存储

* 用户信息
* 用户间关系信息
* 用户间回话信息
* 群组信息
* 事务管理：核心业务需要确保消息的插入操作要么全部成功，要么全部失败。
* 分布式事务：对于涉及多个服务的事务，可以使用分布（例如创建群，先创建群session，然后将各个用户加入到群session中。如果一个用户同时在双端创建，只有一个能创建成功）

##### 搜索内容：Elasticsearch

* 消息搜索
* 群组搜索
* 用户搜索
* 全文搜索

##### 热数据持久化：MongoDB

* 聊天记录：用户、群组历史聊天记录
* 系统消息记录
* 离线消息记录

##### 冷数据持久化：HBase + MySQL

* 一对用户信息就存储在一张表中，表以Hash存在HBase
* MySQL存储用户间的HBase的Hash表索引

##### 文件存储：MinIO

* 文件存储：图片、视频、音频、文档、压缩包等

#### 4.消息路由与分发（接入层）

Spring Cloud Gateway

Sentiel：

* 限流
* 熔断
* 监控

网关：跨服务器消息路由方案:RPC和MQ

**消息路由策略**：

- **基于用户ID**：根据用户ID将消息路由到相应的服务节点。
- **基于群组ID**：对于群聊消息，根据群组ID进行路由。
- **动态路由**：根据当前系统负载情况动态调整路由策略，例如使用负载均衡算法（如一致性哈希）来分配请求。
- **智能调度**：引入 **机器学习** 模型，根据历史数据预测未来的负载情况，提前进行资源调度。

**负载均衡**：

- **服务发现与负载均衡**：使用Nacos，Nginx进行服务发现和负载均衡，确保请求均匀分布到各个服务节点。
  - 注册服务
  - 服务发现
  - 配置管理
- **API网关**：使用Spring Cloud Gateway进行请求路由和负载均衡，支持动态路由配置。

#### 5.前端获取消息策略

##### 前端收到消息的推送

广播 + 前台Service 进行通知

##### 前端长连接：

* Netty：构建基本长连接
* RemoteService：单独进程保护Netty长连接，避免造成主进程繁忙以至于ANR（Android Not Responding）
* AIDL：主进程与Netty进程进行通讯的方法

##### 数据缓存

* LruCache：前端的Redis用于存储缓存消息
* 内存队列：Queue
* Android的MQ：Handler，异步处理网络请求，防止统一资源有过多线程等待造成CPU繁忙

##### 消息获取与合并

* 数据源：
  * Socket消息：后端推送给前端的消息
  * Http消息：用户拉取未处理的消息
  * SQLite消息：本地持久化消息
  * 输入框消息：发送端将输入的消息发送
* 数据处理方案：
  * 未打开Chat页面：
    * Http获取未处理的消息
    * 首次打开调用Http获取未处理的消息 -> Handler消息队列等待处理 -> SQLite持久化（前端即时持久化，不考虑性能，考虑及时性存储）
    * LruCache克隆后端的Redis

      * 1.存储List中的1条未读消息 + 未读消息数量。
      * 2.存储会话的20条消息缓存（避免总是访问SQLite造成卡顿）
  * 打开Chat页面
    * 内存缓存中获取Chat的消息列表加载
    * 收到消息立刻存储到SQLite（前端即时持久化，不考虑性能，考虑及时性存储）
    * 多数据源合并：
      * 合并管理：ChatListManager利用timestamp作为索引进行二分排序用于合并数据源，剔除重复消息。
      * 异步处理：List的同步资源会上sync锁，如果多个线程被阻塞等待处理会出现CPU繁忙，需要将多个线程的任务交给Handler消息队列，然后Handler将Runnable任务挂在线程的Looper的MessageQueue等待处理。
      * 当前页面的List交给ChatListManager持有。
      * Socket即时消息交给Handler
      * 上拉详情先查询SQLite，查询到了交给ChatListManager -> 如果SQLite数据也无就调用Http请求（因为可能是后端有数据但是前端是新设备的情况）
      * 更新：ChatListManager合并完数据回调交给ViewModel，ViewModel通过LiveData通知RecyclerView更新，RecyclerView通过DiffUtil根据消息不通进行更新。

#### 6.安全

##### 数据加密

* Filter过滤器 + CBC加密对消息进行加密（加密必然造成消息处理速度变慢）

- **传输加密**：使用TLS/SSL加密传输，确保数据在传输过程中的安全性。
- **存储加密**：对敏感数据（如密码、个人资料）进行加密存储。

##### 安全认证

登录后生成AccessToken和RefreshToken

- **JWT**：使用JSON Web Token (JWT)进行用户认证，确保认证信息的安全性。
- **OAuth2.0**：支持OAuth2.0认证，实现第三方登录功能。

##### 权限管理

- **RBAC**：实现基于角色的访问控制（RBAC），管理用户的权限。
- **细粒度权限**：支持细粒度的权限管理，确保不同用户有不同的操作权限。
- **动态权限**：支持动态权限管理，根据用户的行为和上下文动态调整权限。
- **最小权限原则**：遵循最小权限原则，确保用户只拥有完成其工作所需的最低权限。

#### 7. 监控系统

1. **系统监控**：

   - **Prometheus**：使用Prometheus进行系统监控，收集和存储各种指标数据。
     - 性能监控
     - 资源监控
     - 业务监控
     - 告警
   - **Grafana**：使用Grafana进行可视化展示，实时监控系统状态。
   - **链路追踪**：使用SkyWalking等链路追踪工具，实现全链路的监控和诊断，快速定位问题。
     - 分布式追踪
     - 性能指标
   - **性能监控**：监控系统的各项性能指标（如CPU、内存、网络带宽），及时发现和解决性能瓶颈。
2. **日志监控**：

   - **ELK**：使用ELK（Elasticsearch, Logstash, Kibana）进行日志收集和分析，支持日志的实时查询和告警。
   - **日志级别**：设置合理的日志级别，区分不同的日志类型（如INFO、ERROR、DEBUG）。
   - **智能告警**：使用机器学习算法，自动检测异常行为，及时发出告警。
   - **日志分析**：使用ELK栈进行日志分析，快速定位和解决问题。
3. **容器管理**：

   - **Kubernetes**：使用Kubernetes进行容器管理，实现自动化部署、扩展和管理。
   - **Docker Swarm**：作为备选方案，使用Docker Swarm进行容器编排。
   - **多区域部署**：在不同地理区域部署多个数据中心，提高系统的容灾能力和访问速度。
   - **多云部署**：使用多云策略，避免单一云服务商的依赖风险，提高系统的灵活性和可用性。
   - **容器网络**：优化容器网络配置，减少网络延迟，提高通信效率。
4. **CI/CD**：

   - **Jenkins**：使用Jenkins实现持续集成和持续交付（CI/CD）。
   - **GitLab CI/CD**：作为备选方案，使用GitLab CI/CD进行自动化构建和部署。
   - **CI/CD管道**：优化CI/CD管道，实现从代码提交到部署的全流程自动化。
   - **自动化测试**：引入自动化测试工具（如Selenium、JMeter），确保系统的质量和稳定性。

#### 8. 高并发

##### 8.1 水平扩展

* **服务实例扩展**：
  - **多实例部署**：通过增加服务实例的数量，提高系统的处理能力。
  - **负载均衡**：使用Nginx或HAProxy进行负载均衡，确保请求均匀分布到各个服务实例。
  - **自动伸缩**：利用Kubernetes的HPA（Horizontal Pod Autoscaler）和VPA（Vertical Pod Autoscaler）进行自动伸缩，根据实际负载动态调整资源。
  - **蓝绿部署**：采用蓝绿部署策略，确保新版本的平滑过渡，减少停机时间。
* **数据库分片**：
  - **水平分片**：将数据库按照用户ID或其他维度进行水平分片，减少单个数据库的负载。
  - **读写分离**：实现读写分离，提高数据库的读取性能。

##### 8.2 异步处理

* **消息队列**：
  - **流量削峰**：使用RocketMQ进行流量削峰，处理突发的高并发请求。
  - **异步任务**：将耗时的操作（如消息存储、通知发送）放入消息队列，异步处理。
  - **事件总线**：引入事件总线（如Apache Kafka、RabbitMQ），实现事件驱动的架构，提高系统的解耦和响应速度。
  - **异步工作流**：使用异步工作流引擎（如Zeebe、Camunda）管理复杂的业务流程，确保任务的高效执行。
* **异步API**：
  - **异步调用**：使用异步API进行服务调用，减少响应时间。
  - **回调机制**：实现回调机制，处理异步操作的结果。
  - **定时任务**：使用Quartz等定时任务调度框架，管理定期执行的任务，确保任务的准时执行。
  - **延迟任务**：使用延迟队列（如Redis的ZSET），管理延迟执行的任务，减少系统负担。

##### 8.3 缓存策略

1. **数据缓存**：

   - **Redis缓存**：使用Redis进行数据缓存，减少数据库访问压力。
   - **缓存更新策略**：实现缓存更新策略，确保数据的一致性。
   - **本地缓存**：在服务实例中使用本地缓存（如Caffeine），减少远程调用的开销。
   - **分布式缓存**：使用Redis Cluster或Codis等分布式缓存，提高缓存的可用性和扩展性。
   - **缓存预热**：在系统启动或高峰时段前，预先加载热点数据到缓存中，减少冷启动的延迟。
   - **缓存刷新**：定期刷新缓存数据，确保数据的时效性。
2. **接口缓存**：

   - **API缓存**：对频繁访问的接口进行缓存，提高响应速度。
   - **缓存失效策略**：设置合理的缓存失效时间，确保数据的时效性。

##### 8.4 资源优化

1. **连接池**：

   - **数据库连接池**：使用HikariCP等连接池管理数据库连接，提高数据库访问效率。
   - **HTTP连接池**：使用OkHttp等库管理HTTP连接，减少连接开销。
2. **线程池**：

   - **线程池管理**：使用Java的Executor框架管理线程池，合理分配线程资源。

#### 9.分布式部署方案

##### 9.1 容器化部署

1. **Docker镜像**：

   - **镜像构建**：使用Dockerfile构建服务的Docker镜像。
   - **镜像推送**：将构建好的镜像推送到Docker Registry，如Docker Hub或私有Registry。
   - **多区域部署**：在不同地理区域部署多个数据中心，提高系统的容灾能力和访问速度。
   - **多云部署**：使用多云策略，避免单一云服务商的依赖风险，提高系统的灵活性和可用性。
   - **容器网络**：优化容器网络配置，减少网络延迟，提高通信效率。
2. **Kubernetes集群**：

   - **集群搭建**：搭建Kubernetes集群，使用kubeadm进行集群初始化。
   - **服务部署**：使用Kubernetes的Deployment、Service、Ingress等资源进行服务的部署和管理。
   - **自动扩展**：使用Horizontal Pod Autoscaler (HPA)实现服务的自动扩展。
   - **服务网格**：引入服务网格（如Istio、Linkerd），实现服务间的透明通信和流量管理。

##### 9.2 微服务架构

1. **服务拆分**：

   - **功能模块化**：将系统拆分为多个独立的服务模块，每个模块负责特定的功能。
   - **服务边界清晰**：明确服务之间的边界，减少服务间的耦合。
   - **领域驱动设计**：根据业务领域进行服务划分，确保每个服务的职责清晰，减少服务间的依赖。
   - **自治服务**：每个服务应具有独立的数据存储和业务逻辑，减少服务间的耦合。
2. **服务治理**：

   - **服务注册与发现**：使用Nacos进行服务注册与发现，确保服务的动态管理和负载均衡。
   - **服务熔断与降级**：使用Resilience4j实现服务熔断和降级，提高系统的容错能力。
   - **服务版本管理**：使用API版本管理，确保不同版本的服务可以同时运行，方便新功能的逐步上线。
   - **灰度发布**：采用灰度发布策略，逐步将新版本的服务推向生产环境，减少风险。

#### 10.扩展性和可维护性

##### 10.1 微服务设计

1. **服务拆分**：

   - **功能模块化**：将系统拆分为多个独立的服务模块，每个模块负责特定的功能。
   - **服务边界清晰**：明确服务之间的边界，减少服务间的耦合。
   - **领域驱动设计**：根据业务领域进行服务划分，确保每个服务的职责清晰，减少服务间的依赖。
   - **自治服务**：每个服务应具有独立的数据存储和业务逻辑，减少服务间的耦合。
2. **服务治理**：

   - **服务注册与发现**：使用Nacos进行服务注册与发现，确保服务的动态管理和负载均衡。
   - **服务熔断与降级**：使用Resilience4j实现服务熔断和降级，提高系统的容错能力。
   - **服务版本管理**：使用API版本管理，确保不同版本的服务可以同时运行，方便新功能的逐步上线。
   - **灰度发布**：采用灰度发布策略，逐步将新版本的服务推向生产环境，减少风险。
